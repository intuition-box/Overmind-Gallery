{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-b85f9cfe4cab07e9559623a9ebaedd8f56f2ba7b",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/gbm/Diamond.sol": "project/contracts/gbm/Diamond.sol",
    "contracts/gbm/facets/DiamondCutFacet.sol": "project/contracts/gbm/facets/DiamondCutFacet.sol",
    "contracts/gbm/facets/DiamondLoupeFacet.sol": "project/contracts/gbm/facets/DiamondLoupeFacet.sol",
    "contracts/gbm/facets/GBM_TRUSTFacet.sol": "project/contracts/gbm/facets/GBM_TRUSTFacet.sol",
    "contracts/gbm/facets/GBMFacet.sol": "project/contracts/gbm/facets/GBMFacet.sol",
    "contracts/gbm/facets/OwnershipFacet.sol": "project/contracts/gbm/facets/OwnershipFacet.sol",
    "contracts/gbm/facets/SettingsFacet.sol": "project/contracts/gbm/facets/SettingsFacet.sol",
    "contracts/gbm/interfaces/IDiamondCut.sol": "project/contracts/gbm/interfaces/IDiamondCut.sol",
    "contracts/gbm/interfaces/IDiamondLoupe.sol": "project/contracts/gbm/interfaces/IDiamondLoupe.sol",
    "contracts/gbm/interfaces/IERC1155.sol": "project/contracts/gbm/interfaces/IERC1155.sol",
    "contracts/gbm/interfaces/IERC1155TokenReceiver.sol": "project/contracts/gbm/interfaces/IERC1155TokenReceiver.sol",
    "contracts/gbm/interfaces/IERC165.sol": "project/contracts/gbm/interfaces/IERC165.sol",
    "contracts/gbm/interfaces/IERC173.sol": "project/contracts/gbm/interfaces/IERC173.sol",
    "contracts/gbm/interfaces/IERC20.sol": "project/contracts/gbm/interfaces/IERC20.sol",
    "contracts/gbm/interfaces/IERC721.sol": "project/contracts/gbm/interfaces/IERC721.sol",
    "contracts/gbm/interfaces/IERC721TokenReceiver.sol": "project/contracts/gbm/interfaces/IERC721TokenReceiver.sol",
    "contracts/gbm/interfaces/IGBM.sol": "project/contracts/gbm/interfaces/IGBM.sol",
    "contracts/gbm/interfaces/IGBMInitiator.sol": "project/contracts/gbm/interfaces/IGBMInitiator.sol",
    "contracts/gbm/interfaces/Ownable.sol": "project/contracts/gbm/interfaces/Ownable.sol",
    "contracts/gbm/libraries/AppStorage.sol": "project/contracts/gbm/libraries/AppStorage.sol",
    "contracts/gbm/libraries/LibDiamond.sol": "project/contracts/gbm/libraries/LibDiamond.sol",
    "contracts/gbm/libraries/LibSignature.sol": "project/contracts/gbm/libraries/LibSignature.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/gbm/Diamond.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"./libraries/LibDiamond.sol\";\nimport \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}"
      },
      "project/contracts/gbm/facets/DiamondCutFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        if (selectorCount & 7 > 0) {\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}"
      },
      "project/contracts/gbm/facets/DiamondLoupeFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop = false;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continueLoop = false;\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop = false;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continueLoop = false;\n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}"
      },
      "project/contracts/gbm/facets/GBM_TRUSTFacet.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n// © Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\n// Modified for Overmind Gallery to use $TRUST token instead of GHST\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IGBM.sol\";\nimport \"../interfaces/IGBMInitiator.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721TokenReceiver.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC1155TokenReceiver.sol\";\nimport \"../interfaces/Ownable.sol\";\nimport \"../libraries/AppStorage.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../libraries/LibSignature.sol\";\n\n/// @title GBM auction contract adapted for $TRUST token\n/// @dev Modified version of GBMFacet.sol for Overmind Gallery using $TRUST instead of GHST\n/// @author Guillaume Gonnaud - Modified by Overmind Gallery Team\ncontract GBM_TRUSTFacet is IGBM, IERC1155TokenReceiver, IERC721TokenReceiver, Modifiers {\n    function erc20Currency() external view override returns (address) {\n        return s.erc20Currency;\n    }\n\n    /// @notice Place a GBM bid for a GBM auction\n    /// @param _auctionId The auction you want to bid on\n    /// @param _bidAmount The amount of $TRUST token the bid is made of. They should be withdrawable by this contract.\n    /// @param _highestBid The current highest bid. Throw if incorrect.\n    /// @param _signature Signature\n    function commitBid(\n        uint256 _auctionId,\n        uint256 _bidAmount,\n        uint256 _highestBid,\n        bytes memory _signature\n    ) external {\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, _auctionId, _bidAmount, _highestBid));\n        require(LibSignature.isValid(messageHash, _signature, s.backendPubKey), \"bid: Invalid signature\");\n\n        bid(_auctionId, _bidAmount, _highestBid);\n    }\n\n    /// @notice Place a GBM bid for a GBM auction\n    /// @param _auctionId The auction you want to bid on\n    /// @param _bidAmount The amount of $TRUST token the bid is made of. They should be withdrawable by this contract.\n    /// @param _highestBid The current highest bid. Throw if incorrect.\n    function bid(\n        uint256 _auctionId,\n        uint256 _bidAmount,\n        uint256 _highestBid\n    ) internal {\n        require(s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed, \"bid: bidding is currently not allowed\");\n\n        require(_bidAmount > 1, \"bid: _bidAmount cannot be 0\");\n\n        require(_highestBid == s.auctions[_auctionId].highestBid, \"bid: current highest bid does not match the submitted transaction _highestBid\");\n\n        //An auction start time of 0 also indicate the auction has not been created at all\n\n        require(getAuctionStartTime(_auctionId) <= block.timestamp && getAuctionStartTime(_auctionId) != 0, \"bid: Auction has not started yet\");\n        require(getAuctionEndTime(_auctionId) >= block.timestamp, \"bid: Auction has already ended\");\n\n        require(_bidAmount > _highestBid, \"bid: _bidAmount must be higher than _highestBid\");\n\n        require(\n            // (_highestBid * (getAuctionBidDecimals(_auctionId)) + (getAuctionStepMin(_auctionId) / getAuctionBidDecimals(_auctionId))) >= _highestBid,\n            // \"bid: _bidAmount must meet the minimum bid\"\n\n            (_highestBid * (getAuctionBidDecimals(_auctionId) + getAuctionStepMin(_auctionId))) <= (_bidAmount * getAuctionBidDecimals(_auctionId)),\n            \"bid: _bidAmount must meet the minimum bid\"\n        );\n\n        //Transfer the money of the bidder to the GBM smart contract\n        IERC20(s.erc20Currency).transferFrom(msg.sender, address(this), _bidAmount);\n\n        //Extend the duration time of the auction if we are close to the end\n        if (getAuctionEndTime(_auctionId) < block.timestamp + getAuctionHammerTimeDuration(_auctionId)) {\n            s.auctions[_auctionId].endTime = block.timestamp + getAuctionHammerTimeDuration(_auctionId);\n            emit Auction_EndTimeUpdated(_auctionId, s.auctions[_auctionId].endTime);\n        }\n\n        // Saving incentives for later sending\n        uint256 duePay = s.auctions[_auctionId].dueIncentives;\n        address previousHighestBidder = s.auctions[_auctionId].highestBidder;\n        uint256 previousHighestBid = s.auctions[_auctionId].highestBid;\n\n        // Emitting the event sequence\n        if (previousHighestBidder != address(0)) {\n            emit Auction_BidRemoved(_auctionId, previousHighestBidder, previousHighestBid);\n        }\n\n        if (duePay != 0) {\n            s.auctions[_auctionId].auctionDebt = s.auctions[_auctionId].auctionDebt + duePay;\n            emit Auction_IncentivePaid(_auctionId, previousHighestBidder, duePay);\n        }\n\n        emit Auction_BidPlaced(_auctionId, msg.sender, _bidAmount);\n\n        // Calculating incentives for the new bidder\n        s.auctions[_auctionId].dueIncentives = calculateIncentives(_auctionId, _bidAmount);\n\n        //Setting the new bid/bidder as the highest bid/bidder\n        s.auctions[_auctionId].highestBidder = msg.sender;\n        s.auctions[_auctionId].highestBid = _bidAmount;\n\n        if ((previousHighestBid + duePay) != 0) {\n            //Refunding the previous bid as well as sending the incentives\n\n            //Added to prevent revert\n            IERC20(s.erc20Currency).approve(address(this), (previousHighestBid + duePay));\n\n            IERC20(s.erc20Currency).transferFrom(address(this), previousHighestBidder, (previousHighestBid + duePay));\n        }\n    }\n\n    function batchClaim(uint256[] memory _auctionIds) external override {\n        for (uint256 index = 0; index < _auctionIds.length; index++) {\n            claim(_auctionIds[index]);\n        }\n    }\n\n    function updatePlayerRewardsAddress(address _newAddress) external onlyOwner {\n        s.playerRewards = _newAddress;\n    }\n\n    /// @notice Attribute a token to the winner of the auction and distribute the proceeds to the owner of this contract.\n    /// throw if bidding is disabled or if the auction is not finished.\n    /// @param _auctionId The auctionId of the auction to complete\n    function claim(uint256 _auctionId) public override {\n        address _ca = s.tokenMapping[_auctionId].contractAddress;\n        uint256 _tid = s.tokenMapping[_auctionId].tokenId;\n\n        require(s.collections[_ca].biddingAllowed, \"claim: Claiming is currently not allowed\");\n        require(getAuctionEndTime(_auctionId) < block.timestamp, \"claim: Auction has not yet ended\");\n        require(s.auctionItemClaimed[_auctionId] == false, \"claim: Item has already been claimed\");\n\n        //Prevents re-entrancy\n        s.auctionItemClaimed[_auctionId] = true;\n\n        // Distribution adapted for Overmind Gallery ecosystem\n        uint256 _proceeds = s.auctions[_auctionId].highestBid - s.auctions[_auctionId].auctionDebt;\n\n        //Added to prevent revert\n        IERC20(s.erc20Currency).approve(address(this), _proceeds);\n\n        //Transfer the proceeds to the various recipients\n        // Adapted for Overmind Gallery: 100% to creator (royalties handled separately)\n        // This can be modified based on the final fee structure decided\n\n        // For now, send 100% to the contract owner (Overmind Gallery treasury)\n        IERC20(s.erc20Currency).transferFrom(address(this), LibDiamond.contractOwner(), _proceeds);\n\n        //todo: test\n        if (s.auctions[_auctionId].highestBid == 0) {\n            s.auctions[_auctionId].highestBidder = LibDiamond.contractOwner();\n        }\n\n        if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC721\"))) {\n            //0x73ad2146\n            IERC721(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid);\n        } else if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC1155\"))) {\n            //0x973bb640\n            IERC1155(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid, 1, \"\");\n            s.erc1155TokensUnderAuction[_ca][_tid] = s.erc1155TokensUnderAuction[_ca][_tid] - 1;\n        }\n\n        emit Auction_ItemClaimed(_auctionId);\n    }\n\n    /// @notice Register an auction contract default parameters for a GBM auction. To use to save gas\n    /// @param _contract The token contract the auctionned token belong to\n    function registerAnAuctionContract(address _contract) public onlyOwner {\n        s.collections[_contract].startTime = s.initiatorInfo.startTime;\n        s.collections[_contract].endTime = s.initiatorInfo.endTime;\n        s.collections[_contract].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\n        s.collections[_contract].bidDecimals = s.initiatorInfo.bidDecimals;\n        s.collections[_contract].stepMin = s.initiatorInfo.stepMin;\n        s.collections[_contract].incMin = s.initiatorInfo.incMin;\n        s.collections[_contract].incMax = s.initiatorInfo.incMax;\n        s.collections[_contract].bidMultiplier = s.initiatorInfo.bidMultiplier;\n    }\n\n    /// @notice Allow/disallow bidding and claiming for a whole token contract address.\n    /// @param _contract The token contract the auctionned token belong to\n    /// @param _value True if bidding/claiming should be allowed.\n    function setBiddingAllowed(address _contract, bool _value) external onlyOwner {\n        s.collections[_contract].biddingAllowed = _value;\n        emit Contract_BiddingAllowed(_contract, _value);\n    }\n\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\n    /// @param _tokenContract The token contract the auctionned token belong to\n    /// @param _tokenId The token ID of the token being auctionned\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\n    /// use `true`)\n    function registerAnAuctionToken(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes4 _tokenKind,\n        bool _useInitiator\n    ) public onlyOwner {\n        modifyAnAuctionToken(_tokenContract, _tokenId, _tokenKind, _useInitiator, 0, false);\n    }\n\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\n    /// @param _tokenContract The token contract the auctionned token belong to\n    /// @param _tokenId The token ID of the token being auctionned\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\n    /// use `true`)\n    /// @param _1155Index Set to 0 if dealing with an ERC-721 or registering new 1155 test. otherwise, set to relevant index you want to reinitialize\n    /// @param _rewrite Set to true if you want to rewrite the data of an existing auction, false otherwise\n    function modifyAnAuctionToken(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes4 _tokenKind,\n        bool _useInitiator,\n        uint256 _1155Index,\n        bool _rewrite\n    ) internal {\n        if (!_rewrite) {\n            _1155Index = s.erc1155TokensIndex[_tokenContract][_tokenId]; //_1155Index was 0 if creating new auctions\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] == 0, \"The auction aleady exist for the specified token\");\n        } else {\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] != 0, \"The auction doesn't exist yet for the specified token\");\n        }\n\n        //Checking the kind of token being registered\n        require(\n            _tokenKind == bytes4(keccak256(\"ERC721\")) || _tokenKind == bytes4(keccak256(\"ERC1155\")),\n            \"registerAnAuctionToken: Only ERC1155 and ERC721 tokens are supported\"\n        );\n\n        //Building the auction object\n        TokenRepresentation memory newAuction;\n        newAuction.contractAddress = _tokenContract;\n        newAuction.tokenId = _tokenId;\n        newAuction.tokenKind = _tokenKind;\n\n        uint256 _auctionId;\n\n        if (_tokenKind == bytes4(keccak256(\"ERC721\"))) {\n            require(\n                msg.sender == Ownable(_tokenContract).owner() || address(this) == IERC721(_tokenContract).ownerOf(_tokenId),\n                \"registerAnAuctionToken: the specified ERC-721 token cannot be auctioned\"\n            );\n\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind)));\n            s.auctionMapping[_tokenContract][_tokenId][0] = _auctionId;\n        } else {\n            require(\n                msg.sender == Ownable(_tokenContract).owner() ||\n                    s.erc1155TokensUnderAuction[_tokenContract][_tokenId] < IERC1155(_tokenContract).balanceOf(address(this), _tokenId),\n                \"registerAnAuctionToken:  the specified ERC-1155 token cannot be auctionned\"\n            );\n\n            require(\n                _1155Index <= s.erc1155TokensIndex[_tokenContract][_tokenId],\n                \"The specified _1155Index have not been reached yet for this token\"\n            );\n\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind, _1155Index)));\n\n            if (!_rewrite) {\n                s.erc1155TokensIndex[_tokenContract][_tokenId] = s.erc1155TokensIndex[_tokenContract][_tokenId] + 1;\n                s.erc1155TokensUnderAuction[_tokenContract][_tokenId] = s.erc1155TokensUnderAuction[_tokenContract][_tokenId] + 1;\n            }\n\n            s.auctionMapping[_tokenContract][_tokenId][_1155Index] = _auctionId;\n        }\n\n        s.tokenMapping[_auctionId] = newAuction;\n\n        if (_useInitiator) {\n            s.auctions[_auctionId].owner = LibDiamond.contractOwner();\n            s.auctions[_auctionId].startTime = s.initiatorInfo.startTime;\n            s.auctions[_auctionId].endTime = s.initiatorInfo.endTime;\n            s.auctions[_auctionId].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\n            s.auctions[_auctionId].bidDecimals = s.initiatorInfo.bidDecimals;\n            s.auctions[_auctionId].stepMin = s.initiatorInfo.stepMin;\n            s.auctions[_auctionId].incMin = s.initiatorInfo.incMin;\n            s.auctions[_auctionId].incMax = s.initiatorInfo.incMax;\n            s.auctions[_auctionId].bidMultiplier = s.initiatorInfo.bidMultiplier;\n        }\n\n        //Event emitted when an auction is being setup\n        emit Auction_Initialized(_auctionId, _tokenId, _1155Index, _tokenContract, _tokenKind);\n\n        //Event emitted when the start time of an auction changes (due to admin interaction )\n        emit Auction_StartTimeUpdated(_auctionId, getAuctionStartTime(_auctionId));\n    }\n\n    function getAuctionInfo(uint256 _auctionId) external view returns (Auction memory auctionInfo_) {\n        auctionInfo_ = s.auctions[_auctionId];\n        auctionInfo_.contractAddress = s.tokenMapping[_auctionId].contractAddress;\n        auctionInfo_.biddingAllowed = s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed;\n    }\n\n    function getAuctionHighestBidder(uint256 _auctionId) external view override returns (address) {\n        return s.auctions[_auctionId].highestBidder;\n    }\n\n    function getAuctionHighestBid(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].highestBid;\n    }\n\n    function getAuctionDebt(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].auctionDebt;\n    }\n\n    function getAuctionDueIncentives(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].dueIncentives;\n    }\n\n    function getAuctionID(address _contract, uint256 _tokenID) external view override returns (uint256) {\n        return s.auctionMapping[_contract][_tokenID][0];\n    }\n\n    function getAuctionID(\n        address _contract,\n        uint256 _tokenID,\n        uint256 _tokenIndex\n    ) external view override returns (uint256) {\n        return s.auctionMapping[_contract][_tokenID][_tokenIndex];\n    }\n\n    function getTokenKind(uint256 _auctionId) external view override returns (bytes4) {\n        return s.tokenMapping[_auctionId].tokenKind;\n    }\n\n    function getTokenId(uint256 _auctionId) external view override returns (uint256) {\n        return s.tokenMapping[_auctionId].tokenId;\n    }\n\n    function getContractAddress(uint256 _auctionId) external view override returns (address) {\n        return s.tokenMapping[_auctionId].contractAddress;\n    }\n\n    function getAuctionStartTime(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].startTime != 0) {\n            return s.auctions[_auctionId].startTime;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].startTime;\n        }\n    }\n\n    function getAuctionEndTime(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].endTime != 0) {\n            return s.auctions[_auctionId].endTime;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].endTime;\n        }\n    }\n\n    function getAuctionHammerTimeDuration(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].hammerTimeDuration != 0) {\n            return s.auctions[_auctionId].hammerTimeDuration;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].hammerTimeDuration;\n        }\n    }\n\n    function getAuctionBidDecimals(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].bidDecimals != 0) {\n            return s.auctions[_auctionId].bidDecimals;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidDecimals;\n        }\n    }\n\n    function getAuctionStepMin(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].stepMin != 0) {\n            return s.auctions[_auctionId].stepMin;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].stepMin;\n        }\n    }\n\n    function getAuctionIncMin(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].incMin != 0) {\n            return s.auctions[_auctionId].incMin;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMin;\n        }\n    }\n\n    function getAuctionIncMax(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].incMax != 0) {\n            return s.auctions[_auctionId].incMax;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMax;\n        }\n    }\n\n    function getAuctionBidMultiplier(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].bidMultiplier != 0) {\n            return s.auctions[_auctionId].bidMultiplier;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidMultiplier;\n        }\n    }\n\n    function onERC721Received(\n        address, /* _operator */\n        address, /*  _from */\n        uint256, /*  _tokenId */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function onERC1155Received(\n        address, /* _operator */\n        address, /* _from */\n        uint256, /* _id */\n        uint256, /* _value */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }\n\n    function onERC1155BatchReceived(\n        address, /* _operator */\n        address, /* _from */\n        uint256[] calldata, /* _ids */\n        uint256[] calldata, /* _values */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }\n\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\n    /// @dev Only callable internally\n    function calculateIncentives(uint256 _auctionId, uint256 _newBidValue) internal view returns (uint256) {\n        uint256 bidDecimals = getAuctionBidDecimals(_auctionId);\n        uint256 bidIncMax = getAuctionIncMax(_auctionId);\n\n        //Init the baseline bid we need to perform against\n        uint256 baseBid = (s.auctions[_auctionId].highestBid * (bidDecimals + getAuctionStepMin(_auctionId))) / bidDecimals;\n\n        //If no bids are present, set a basebid value of 1 to prevent divide by 0 errors\n        if (baseBid == 0) {\n            baseBid = 1;\n        }\n\n        //Ratio of newBid compared to expected minBid\n        uint256 decimaledRatio = ((bidDecimals * getAuctionBidMultiplier(_auctionId) * (_newBidValue - baseBid)) / baseBid) +\n            getAuctionIncMin(_auctionId) *\n            bidDecimals;\n\n        if (decimaledRatio > (bidDecimals * bidIncMax)) {\n            decimaledRatio = bidDecimals * bidIncMax;\n        }\n\n        return (_newBidValue * decimaledRatio) / (bidDecimals * bidDecimals);\n    }\n\n    function registerMassERC721Each(\n        address _GBM,\n        bool _useInitiator,\n        address _ERC721Contract,\n        uint256[] memory _tokenIds\n    ) external onlyOwner {\n        require(_tokenIds.length > 0, \"No auctions to create\");\n        for (uint256 index = 0; index < _tokenIds.length; index++) {\n            uint256 tokenId = _tokenIds[index];\n            IERC721(_ERC721Contract).safeTransferFrom(msg.sender, _GBM, tokenId, \"\");\n            registerAnAuctionToken(_ERC721Contract, tokenId, bytes4(keccak256(\"ERC721\")), _useInitiator);\n        }\n\n        // _tokenIDStart++;\n    }\n\n    function registerMassERC1155Each(\n        address _GBM,\n        bool _useInitiator,\n        address _ERC1155Contract,\n        uint256 _tokenID,\n        uint256 _indexStart,\n        uint256 _indexEnd\n    ) external onlyOwner {\n        registerAnAuctionContract(_ERC1155Contract);\n        IERC1155(_ERC1155Contract).safeTransferFrom(msg.sender, _GBM, _tokenID, _indexEnd - _indexStart, \"\");\n        while (_indexStart < _indexEnd) {\n            registerAnAuctionToken(_ERC1155Contract, _tokenID, bytes4(keccak256(\"ERC1155\")), _useInitiator);\n            _indexStart++;\n        }\n    }\n}"
      },
      "project/contracts/gbm/facets/GBMFacet.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n// © Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IGBM.sol\";\nimport \"../interfaces/IGBMInitiator.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721TokenReceiver.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC1155TokenReceiver.sol\";\nimport \"../interfaces/Ownable.sol\";\nimport \"../libraries/AppStorage.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../libraries/LibSignature.sol\";\n\n/// @title GBM auction contract\n/// @dev See GBM.auction on how to use this contract\n/// @author Guillaume Gonnaud\ncontract GBMFacet is IGBM, IERC1155TokenReceiver, IERC721TokenReceiver, Modifiers {\n    function erc20Currency() external view override returns (address) {\n        return s.erc20Currency;\n    }\n\n    /// @notice Place a GBM bid for a GBM auction\n    /// @param _auctionId The auction you want to bid on\n    /// @param _bidAmount The amount of the ERC20 token the bid is made of. They should be withdrawable by this contract.\n    /// @param _highestBid The current higest bid. Throw if incorrect.\n    /// @param _signature Signature\n    function commitBid(\n        uint256 _auctionId,\n        uint256 _bidAmount,\n        uint256 _highestBid,\n        bytes memory _signature\n    ) external {\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, _auctionId, _bidAmount, _highestBid));\n        require(LibSignature.isValid(messageHash, _signature, s.backendPubKey), \"bid: Invalid signature\");\n\n        bid(_auctionId, _bidAmount, _highestBid);\n    }\n\n    /// @notice Place a GBM bid for a GBM auction\n    /// @param _auctionId The auction you want to bid on\n    /// @param _bidAmount The amount of the ERC20 token the bid is made of. They should be withdrawable by this contract.\n    /// @param _highestBid The current higest bid. Throw if incorrect.\n    function bid(\n        uint256 _auctionId,\n        uint256 _bidAmount,\n        uint256 _highestBid\n    ) internal {\n        require(s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed, \"bid: bidding is currently not allowed\");\n\n        require(_bidAmount > 1, \"bid: _bidAmount cannot be 0\");\n\n        require(_highestBid == s.auctions[_auctionId].highestBid, \"bid: current highest bid does not match the submitted transaction _highestBid\");\n\n        //An auction start time of 0 also indicate the auction has not been created at all\n\n        require(getAuctionStartTime(_auctionId) <= block.timestamp && getAuctionStartTime(_auctionId) != 0, \"bid: Auction has not started yet\");\n        require(getAuctionEndTime(_auctionId) >= block.timestamp, \"bid: Auction has already ended\");\n\n        require(_bidAmount > _highestBid, \"bid: _bidAmount must be higher than _highestBid\");\n\n        require(\n            // (_highestBid * (getAuctionBidDecimals(_auctionId)) + (getAuctionStepMin(_auctionId) / getAuctionBidDecimals(_auctionId))) >= _highestBid,\n            // \"bid: _bidAmount must meet the minimum bid\"\n\n            (_highestBid * (getAuctionBidDecimals(_auctionId) + getAuctionStepMin(_auctionId))) <= (_bidAmount * getAuctionBidDecimals(_auctionId)),\n            \"bid: _bidAmount must meet the minimum bid\"\n        );\n\n        //Transfer the money of the bidder to the GBM smart contract\n        IERC20(s.erc20Currency).transferFrom(msg.sender, address(this), _bidAmount);\n\n        //Extend the duration time of the auction if we are close to the end\n        if (getAuctionEndTime(_auctionId) < block.timestamp + getAuctionHammerTimeDuration(_auctionId)) {\n            s.auctions[_auctionId].endTime = block.timestamp + getAuctionHammerTimeDuration(_auctionId);\n            emit Auction_EndTimeUpdated(_auctionId, s.auctions[_auctionId].endTime);\n        }\n\n        // Saving incentives for later sending\n        uint256 duePay = s.auctions[_auctionId].dueIncentives;\n        address previousHighestBidder = s.auctions[_auctionId].highestBidder;\n        uint256 previousHighestBid = s.auctions[_auctionId].highestBid;\n\n        // Emitting the event sequence\n        if (previousHighestBidder != address(0)) {\n            emit Auction_BidRemoved(_auctionId, previousHighestBidder, previousHighestBid);\n        }\n\n        if (duePay != 0) {\n            s.auctions[_auctionId].auctionDebt = s.auctions[_auctionId].auctionDebt + duePay;\n            emit Auction_IncentivePaid(_auctionId, previousHighestBidder, duePay);\n        }\n\n        emit Auction_BidPlaced(_auctionId, msg.sender, _bidAmount);\n\n        // Calculating incentives for the new bidder\n        s.auctions[_auctionId].dueIncentives = calculateIncentives(_auctionId, _bidAmount);\n\n        //Setting the new bid/bidder as the highest bid/bidder\n        s.auctions[_auctionId].highestBidder = msg.sender;\n        s.auctions[_auctionId].highestBid = _bidAmount;\n\n        if ((previousHighestBid + duePay) != 0) {\n            //Refunding the previous bid as well as sending the incentives\n\n            //Added to prevent revert\n            IERC20(s.erc20Currency).approve(address(this), (previousHighestBid + duePay));\n\n            IERC20(s.erc20Currency).transferFrom(address(this), previousHighestBidder, (previousHighestBid + duePay));\n        }\n    }\n\n    function batchClaim(uint256[] memory _auctionIds) external override {\n        for (uint256 index = 0; index < _auctionIds.length; index++) {\n            claim(_auctionIds[index]);\n        }\n    }\n\n    function updatePlayerRewardsAddress(address _newAddress) external onlyOwner {\n        s.playerRewards = _newAddress;\n    }\n\n    /// @notice Attribute a token to the winner of the auction and distribute the proceeds to the owner of this contract.\n    /// throw if bidding is disabled or if the auction is not finished.\n    /// @param _auctionId The auctionId of the auction to complete\n    function claim(uint256 _auctionId) public override {\n        address _ca = s.tokenMapping[_auctionId].contractAddress;\n        uint256 _tid = s.tokenMapping[_auctionId].tokenId;\n\n        require(s.collections[_ca].biddingAllowed, \"claim: Claiming is currently not allowed\");\n        require(getAuctionEndTime(_auctionId) < block.timestamp, \"claim: Auction has not yet ended\");\n        require(s.auctionItemClaimed[_auctionId] == false, \"claim: Item has already been claimed\");\n\n        //Prevents re-entrancy\n        s.auctionItemClaimed[_auctionId] = true;\n\n        //Todo: Add in the various Aavegotchi addresses\n        uint256 _proceeds = s.auctions[_auctionId].highestBid - s.auctions[_auctionId].auctionDebt;\n\n        //Added to prevent revert\n        IERC20(s.erc20Currency).approve(address(this), _proceeds);\n\n        //Transfer the proceeds to the various recipients\n\n        //5% to burn address\n        uint256 burnShare = (_proceeds * 5) / 100;\n\n        //40% to Pixelcraft wallet\n        uint256 companyShare = (_proceeds * 40) / 100;\n\n        //40% to player rewards\n        uint256 playerRewardsShare = (_proceeds * 2) / 5;\n\n        //15% to DAO\n        uint256 daoShare = (_proceeds - burnShare - companyShare - playerRewardsShare);\n\n        IERC20(s.erc20Currency).transferFrom(address(this), address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF), burnShare);\n        IERC20(s.erc20Currency).transferFrom(address(this), s.pixelcraft, companyShare);\n        IERC20(s.erc20Currency).transferFrom(address(this), s.playerRewards, playerRewardsShare);\n        IERC20(s.erc20Currency).transferFrom(address(this), s.daoTreasury, daoShare);\n\n        //todo: test\n        if (s.auctions[_auctionId].highestBid == 0) {\n            s.auctions[_auctionId].highestBidder = LibDiamond.contractOwner();\n        }\n\n        if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC721\"))) {\n            //0x73ad2146\n            IERC721(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid);\n        } else if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC1155\"))) {\n            //0x973bb640\n            IERC1155(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid, 1, \"\");\n            s.erc1155TokensUnderAuction[_ca][_tid] = s.erc1155TokensUnderAuction[_ca][_tid] - 1;\n        }\n\n        emit Auction_ItemClaimed(_auctionId);\n    }\n\n    /// @notice Register an auction contract default parameters for a GBM auction. To use to save gas\n    /// @param _contract The token contract the auctionned token belong to\n    function registerAnAuctionContract(address _contract) public onlyOwner {\n        s.collections[_contract].startTime = s.initiatorInfo.startTime;\n        s.collections[_contract].endTime = s.initiatorInfo.endTime;\n        s.collections[_contract].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\n        s.collections[_contract].bidDecimals = s.initiatorInfo.bidDecimals;\n        s.collections[_contract].stepMin = s.initiatorInfo.stepMin;\n        s.collections[_contract].incMin = s.initiatorInfo.incMin;\n        s.collections[_contract].incMax = s.initiatorInfo.incMax;\n        s.collections[_contract].bidMultiplier = s.initiatorInfo.bidMultiplier;\n    }\n\n    /// @notice Allow/disallow bidding and claiming for a whole token contract address.\n    /// @param _contract The token contract the auctionned token belong to\n    /// @param _value True if bidding/claiming should be allowed.\n    function setBiddingAllowed(address _contract, bool _value) external onlyOwner {\n        s.collections[_contract].biddingAllowed = _value;\n        emit Contract_BiddingAllowed(_contract, _value);\n    }\n\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\n    /// @param _tokenContract The token contract the auctionned token belong to\n    /// @param _tokenId The token ID of the token being auctionned\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\n    /// use `true`)\n    function registerAnAuctionToken(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes4 _tokenKind,\n        bool _useInitiator\n    ) public onlyOwner {\n        modifyAnAuctionToken(_tokenContract, _tokenId, _tokenKind, _useInitiator, 0, false);\n    }\n\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\n    /// @param _tokenContract The token contract the auctionned token belong to\n    /// @param _tokenId The token ID of the token being auctionned\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\n    /// use `true`)\n    /// @param _1155Index Set to 0 if dealing with an ERC-721 or registering new 1155 test. otherwise, set to relevant index you want to reinitialize\n    /// @param _rewrite Set to true if you want to rewrite the data of an existing auction, false otherwise\n    function modifyAnAuctionToken(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes4 _tokenKind,\n        bool _useInitiator,\n        uint256 _1155Index,\n        bool _rewrite\n    ) internal {\n        if (!_rewrite) {\n            _1155Index = s.erc1155TokensIndex[_tokenContract][_tokenId]; //_1155Index was 0 if creating new auctions\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] == 0, \"The auction aleady exist for the specified token\");\n        } else {\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] != 0, \"The auction doesn't exist yet for the specified token\");\n        }\n\n        //Checking the kind of token being registered\n        require(\n            _tokenKind == bytes4(keccak256(\"ERC721\")) || _tokenKind == bytes4(keccak256(\"ERC1155\")),\n            \"registerAnAuctionToken: Only ERC1155 and ERC721 tokens are supported\"\n        );\n\n        //Building the auction object\n        TokenRepresentation memory newAuction;\n        newAuction.contractAddress = _tokenContract;\n        newAuction.tokenId = _tokenId;\n        newAuction.tokenKind = _tokenKind;\n\n        uint256 _auctionId;\n\n        if (_tokenKind == bytes4(keccak256(\"ERC721\"))) {\n            require(\n                msg.sender == Ownable(_tokenContract).owner() || address(this) == IERC721(_tokenContract).ownerOf(_tokenId),\n                \"registerAnAuctionToken: the specified ERC-721 token cannot be auctioned\"\n            );\n\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind)));\n            s.auctionMapping[_tokenContract][_tokenId][0] = _auctionId;\n        } else {\n            require(\n                msg.sender == Ownable(_tokenContract).owner() ||\n                    s.erc1155TokensUnderAuction[_tokenContract][_tokenId] < IERC1155(_tokenContract).balanceOf(address(this), _tokenId),\n                \"registerAnAuctionToken:  the specified ERC-1155 token cannot be auctionned\"\n            );\n\n            require(\n                _1155Index <= s.erc1155TokensIndex[_tokenContract][_tokenId],\n                \"The specified _1155Index have not been reached yet for this token\"\n            );\n\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind, _1155Index)));\n\n            if (!_rewrite) {\n                s.erc1155TokensIndex[_tokenContract][_tokenId] = s.erc1155TokensIndex[_tokenContract][_tokenId] + 1;\n                s.erc1155TokensUnderAuction[_tokenContract][_tokenId] = s.erc1155TokensUnderAuction[_tokenContract][_tokenId] + 1;\n            }\n\n            s.auctionMapping[_tokenContract][_tokenId][_1155Index] = _auctionId;\n        }\n\n        s.tokenMapping[_auctionId] = newAuction;\n\n        if (_useInitiator) {\n            s.auctions[_auctionId].owner = LibDiamond.contractOwner();\n            s.auctions[_auctionId].startTime = s.initiatorInfo.startTime;\n            s.auctions[_auctionId].endTime = s.initiatorInfo.endTime;\n            s.auctions[_auctionId].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\n            s.auctions[_auctionId].bidDecimals = s.initiatorInfo.bidDecimals;\n            s.auctions[_auctionId].stepMin = s.initiatorInfo.stepMin;\n            s.auctions[_auctionId].incMin = s.initiatorInfo.incMin;\n            s.auctions[_auctionId].incMax = s.initiatorInfo.incMax;\n            s.auctions[_auctionId].bidMultiplier = s.initiatorInfo.bidMultiplier;\n        }\n\n        //Event emitted when an auction is being setup\n        emit Auction_Initialized(_auctionId, _tokenId, _1155Index, _tokenContract, _tokenKind);\n\n        //Event emitted when the start time of an auction changes (due to admin interaction )\n        emit Auction_StartTimeUpdated(_auctionId, getAuctionStartTime(_auctionId));\n    }\n\n    function getAuctionInfo(uint256 _auctionId) external view returns (Auction memory auctionInfo_) {\n        auctionInfo_ = s.auctions[_auctionId];\n        auctionInfo_.contractAddress = s.tokenMapping[_auctionId].contractAddress;\n        auctionInfo_.biddingAllowed = s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed;\n    }\n\n    function getAuctionHighestBidder(uint256 _auctionId) external view override returns (address) {\n        return s.auctions[_auctionId].highestBidder;\n    }\n\n    function getAuctionHighestBid(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].highestBid;\n    }\n\n    function getAuctionDebt(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].auctionDebt;\n    }\n\n    function getAuctionDueIncentives(uint256 _auctionId) external view override returns (uint256) {\n        return s.auctions[_auctionId].dueIncentives;\n    }\n\n    function getAuctionID(address _contract, uint256 _tokenID) external view override returns (uint256) {\n        return s.auctionMapping[_contract][_tokenID][0];\n    }\n\n    function getAuctionID(\n        address _contract,\n        uint256 _tokenID,\n        uint256 _tokenIndex\n    ) external view override returns (uint256) {\n        return s.auctionMapping[_contract][_tokenID][_tokenIndex];\n    }\n\n    function getTokenKind(uint256 _auctionId) external view override returns (bytes4) {\n        return s.tokenMapping[_auctionId].tokenKind;\n    }\n\n    function getTokenId(uint256 _auctionId) external view override returns (uint256) {\n        return s.tokenMapping[_auctionId].tokenId;\n    }\n\n    function getContractAddress(uint256 _auctionId) external view override returns (address) {\n        return s.tokenMapping[_auctionId].contractAddress;\n    }\n\n    function getAuctionStartTime(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].startTime != 0) {\n            return s.auctions[_auctionId].startTime;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].startTime;\n        }\n    }\n\n    function getAuctionEndTime(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].endTime != 0) {\n            return s.auctions[_auctionId].endTime;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].endTime;\n        }\n    }\n\n    function getAuctionHammerTimeDuration(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].hammerTimeDuration != 0) {\n            return s.auctions[_auctionId].hammerTimeDuration;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].hammerTimeDuration;\n        }\n    }\n\n    function getAuctionBidDecimals(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].bidDecimals != 0) {\n            return s.auctions[_auctionId].bidDecimals;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidDecimals;\n        }\n    }\n\n    function getAuctionStepMin(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].stepMin != 0) {\n            return s.auctions[_auctionId].stepMin;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].stepMin;\n        }\n    }\n\n    function getAuctionIncMin(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].incMin != 0) {\n            return s.auctions[_auctionId].incMin;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMin;\n        }\n    }\n\n    function getAuctionIncMax(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].incMax != 0) {\n            return s.auctions[_auctionId].incMax;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMax;\n        }\n    }\n\n    function getAuctionBidMultiplier(uint256 _auctionId) public view override returns (uint256) {\n        if (s.auctions[_auctionId].bidMultiplier != 0) {\n            return s.auctions[_auctionId].bidMultiplier;\n        } else {\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidMultiplier;\n        }\n    }\n\n    function onERC721Received(\n        address, /* _operator */\n        address, /*  _from */\n        uint256, /*  _tokenId */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function onERC1155Received(\n        address, /* _operator */\n        address, /* _from */\n        uint256, /* _id */\n        uint256, /* _value */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }\n\n    function onERC1155BatchReceived(\n        address, /* _operator */\n        address, /* _from */\n        uint256[] calldata, /* _ids */\n        uint256[] calldata, /* _values */\n        bytes calldata /* _data */\n    ) external pure override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }\n\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\n    /// @dev Only callable internally\n    function calculateIncentives(uint256 _auctionId, uint256 _newBidValue) internal view returns (uint256) {\n        uint256 bidDecimals = getAuctionBidDecimals(_auctionId);\n        uint256 bidIncMax = getAuctionIncMax(_auctionId);\n\n        //Init the baseline bid we need to perform against\n        uint256 baseBid = (s.auctions[_auctionId].highestBid * (bidDecimals + getAuctionStepMin(_auctionId))) / bidDecimals;\n\n        //If no bids are present, set a basebid value of 1 to prevent divide by 0 errors\n        if (baseBid == 0) {\n            baseBid = 1;\n        }\n\n        //Ratio of newBid compared to expected minBid\n        uint256 decimaledRatio = ((bidDecimals * getAuctionBidMultiplier(_auctionId) * (_newBidValue - baseBid)) / baseBid) +\n            getAuctionIncMin(_auctionId) *\n            bidDecimals;\n\n        if (decimaledRatio > (bidDecimals * bidIncMax)) {\n            decimaledRatio = bidDecimals * bidIncMax;\n        }\n\n        return (_newBidValue * decimaledRatio) / (bidDecimals * bidDecimals);\n    }\n\n    function registerMassERC721Each(\n        address _GBM,\n        bool _useInitiator,\n        address _ERC721Contract,\n        uint256[] memory _tokenIds\n    ) external onlyOwner {\n        require(_tokenIds.length > 0, \"No auctions to create\");\n        for (uint256 index = 0; index < _tokenIds.length; index++) {\n            uint256 tokenId = _tokenIds[index];\n            IERC721(_ERC721Contract).safeTransferFrom(msg.sender, _GBM, tokenId, \"\");\n            registerAnAuctionToken(_ERC721Contract, tokenId, bytes4(keccak256(\"ERC721\")), _useInitiator);\n        }\n\n        // _tokenIDStart++;\n    }\n\n    function registerMassERC1155Each(\n        address _GBM,\n        bool _useInitiator,\n        address _ERC1155Contract,\n        uint256 _tokenID,\n        uint256 _indexStart,\n        uint256 _indexEnd\n    ) external onlyOwner {\n        registerAnAuctionContract(_ERC1155Contract);\n        IERC1155(_ERC1155Contract).safeTransferFrom(msg.sender, _GBM, _tokenID, _indexEnd - _indexStart, \"\");\n        while (_indexStart < _indexEnd) {\n            registerAnAuctionToken(_ERC1155Contract, _tokenID, bytes4(keccak256(\"ERC1155\")), _useInitiator);\n            _indexStart++;\n        }\n    }\n}"
      },
      "project/contracts/gbm/facets/OwnershipFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}"
      },
      "project/contracts/gbm/facets/SettingsFacet.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n// © Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IGBMInitiator.sol\";\nimport \"../libraries/AppStorage.sol\";\nimport \"../libraries/LibDiamond.sol\";\n\n/// @title GBM auction contract Initiator\n/// @dev Implementation of IGBM. Feel free to cook up your own implementation for more complex patterns.\n/// @author Guillaume Gonnaud\ncontract SettingsFacet is IGBMInitiator, Modifiers {\n    // To future developers: All the getters are called AFTER the auction ID has been generated and hence you can lookup\n    // token_ID/Token contract/token kind using the main GBM contract getters(auctionId) if you want to return determinstic values\n\n    function getInitiatorInfo() external view returns (InitiatorInfo memory) {\n        return s.initiatorInfo;\n    }\n\n    function getStartTime(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.startTime;\n    }\n\n    function getEndTime(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.endTime;\n    }\n\n    function getHammerTimeDuration(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.hammerTimeDuration;\n    }\n\n    function getBidDecimals(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.bidDecimals;\n    }\n\n    function getStepMin(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.stepMin;\n    }\n\n    function getIncMin(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.incMin;\n    }\n\n    function getIncMax(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.incMax;\n    }\n\n    function getBidMultiplier(\n        uint256 /* _auctionId */\n    ) external view override returns (uint256) {\n        return s.initiatorInfo.bidMultiplier;\n    }\n\n    /* Setter Functions */\n\n    function setInitiatorInfo(InitiatorInfo memory _info) external onlyOwner {\n        s.initiatorInfo = _info;\n    }\n\n    function setBackendPubKey(bytes memory _backendPubKey) external onlyOwner {\n        s.backendPubKey = _backendPubKey;\n    }\n}"
      },
      "project/contracts/gbm/interfaces/IDiamondCut.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}"
      },
      "project/contracts/gbm/interfaces/IDiamondLoupe.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondLoupe {\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}"
      },
      "project/contracts/gbm/interfaces/IERC1155.sol": {
        "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 /* is ERC165 */ {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    /**\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\n    */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n        @dev MUST emit when the URI is updated for a token ID.\n        URIs are defined in RFC 3986.\n        The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the successful transfer, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the successful transfer, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155BatchReceived` on `_to`\n    */\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice Get the balance of an account's tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the token\n        @return        The _owner's balance of the token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the tokens\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}"
      },
      "project/contracts/gbm/interfaces/IERC1155TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/**\n    @title ERC-1155 Multi Token Receiver\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n*/\ninterface IERC1155TokenReceiver {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param _operator The address which initiated the transfer (i.e. msg.sender)\n        @param _from The address which previously owned the token\n        @param _id The ID of the token being transferred\n        @param _value The amount of tokens being transferred\n        @param _data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param _operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param _from The address which previously owned the token\n        @param _ids An array containing ids of each token being transferred (order and length must match _values array)\n        @param _values An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param _data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}"
      },
      "project/contracts/gbm/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-165 Standard Interface Detection\n/// @dev See https://eips.ethereum.org/EIPS/eip-165\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}"
      },
      "project/contracts/gbm/interfaces/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}"
      },
      "project/contracts/gbm/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
      },
      "project/contracts/gbm/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is ERC165 */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}"
      },
      "project/contracts/gbm/interfaces/IERC721TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}"
      },
      "project/contracts/gbm/interfaces/IGBM.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n// © Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity ^0.8.0;\n\n/// @title IGBM GBM auction interface\n/// @dev See GBM.auction on how to use this contract\n/// @author Guillaume Gonnaud\ninterface IGBM {\n    //Event emitted when an auction is being setup\n    event Auction_Initialized(\n        uint256 indexed _auctionID,\n        uint256 indexed _tokenID,\n        uint256 indexed _tokenIndex,\n        address _contractAddress,\n        bytes4 _tokenKind\n    );\n\n    //Event emitted when the start time of an auction changes (due to admin interaction )\n    event Auction_StartTimeUpdated(uint256 indexed _auctionID, uint256 _startTime);\n\n    //Event emitted when the end time of an auction changes (be it due to admin interaction or bid at the end)\n    event Auction_EndTimeUpdated(uint256 indexed _auctionID, uint256 _endTime);\n\n    //Event emitted when a Bid is placed\n    event Auction_BidPlaced(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\n\n    //Event emitted when a bid is removed (due to a new bid displacing it)\n    event Auction_BidRemoved(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\n\n    //Event emitted when incentives are paid (due to a new bid rewarding the _earner bid)\n    event Auction_IncentivePaid(uint256 indexed _auctionID, address indexed _earner, uint256 _incentiveAmount);\n\n    event Contract_BiddingAllowed(address indexed _contract, bool _biddingAllowed);\n\n    event Auction_ItemClaimed(uint256 indexed _auctionID);\n\n    //    function bid(\n    //        uint256 _auctionID,\n    //        uint256 _bidAmount,\n    //        uint256 _highestBid\n    //    ) external;\n\n    function batchClaim(uint256[] memory _auctionIds) external;\n\n    function claim(uint256 _auctionId) external;\n\n    function erc20Currency() external view returns (address);\n\n    function getAuctionID(address _contract, uint256 _tokenID) external view returns (uint256);\n\n    function getAuctionID(\n        address _contract,\n        uint256 _tokenID,\n        uint256 _tokenIndex\n    ) external view returns (uint256);\n\n    function getTokenId(uint256 _auctionId) external view returns (uint256);\n\n    function getContractAddress(uint256 _auctionId) external view returns (address);\n\n    function getTokenKind(uint256 _auctionId) external view returns (bytes4);\n\n    function getAuctionHighestBidder(uint256 _auctionId) external view returns (address);\n\n    function getAuctionHighestBid(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionDebt(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionDueIncentives(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionStartTime(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionEndTime(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionHammerTimeDuration(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionBidDecimals(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionStepMin(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionIncMin(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionIncMax(uint256 _auctionId) external view returns (uint256);\n\n    function getAuctionBidMultiplier(uint256 _auctionId) external view returns (uint256);\n}"
      },
      "project/contracts/gbm/interfaces/IGBMInitiator.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n// © Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity ^0.8.0;\n\n/// @title IGBMInitiator: GBM Auction initiator interface.\n/// @dev Will be called when initializing GBM auctions on the main GBM contract.\n/// @author Guillaume Gonnaud\ninterface IGBMInitiator {\n    // Auction id either = the contract token address cast as uint256 or\n    // auctionId = uint256(keccak256(abi.encodePacked(_contract, _tokenId, _tokenKind)));  <= ERC721\n    // auctionId = uint256(keccak256(abi.encodePacked(_contract, _tokenId, _tokenKind, _1155Index))); <= ERC1155\n\n    function getStartTime(uint256 _auctionId) external view returns (uint256);\n\n    function getEndTime(uint256 _auctionId) external view returns (uint256);\n\n    function getHammerTimeDuration(uint256 _auctionId) external view returns (uint256);\n\n    function getBidDecimals(uint256 _auctionId) external view returns (uint256);\n\n    function getStepMin(uint256 _auctionId) external view returns (uint256);\n\n    function getIncMin(uint256 _auctionId) external view returns (uint256);\n\n    function getIncMax(uint256 _auctionId) external view returns (uint256);\n\n    function getBidMultiplier(uint256 _auctionId) external view returns (uint256);\n}"
      },
      "project/contracts/gbm/interfaces/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Ownable {\n    function owner() external view returns (address);\n}"
      },
      "project/contracts/gbm/libraries/AppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {LibDiamond} from \"./LibDiamond.sol\";\n\n//Struct used to store the representation of an NFT being auctionned\nstruct TokenRepresentation {\n    address contractAddress; // The contract address\n    uint256 tokenId; // The ID of the token on the contract\n    bytes4 tokenKind; // The ERC name of the token implementation bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\n}\n\nstruct ContractAddresses {\n    address pixelcraft;\n    address playerRewards;\n    address daoTreasury;\n    address erc20Currency;\n}\n\nstruct InitiatorInfo {\n    uint256 startTime;\n    uint256 endTime;\n    uint256 hammerTimeDuration;\n    uint256 bidDecimals;\n    uint256 stepMin;\n    uint256 incMin;\n    uint256 incMax;\n    uint256 bidMultiplier;\n}\n\nstruct Auction {\n    address owner;\n    address highestBidder;\n    uint256 highestBid;\n    uint256 auctionDebt;\n    uint256 dueIncentives;\n    address contractAddress;\n    uint256 startTime;\n    uint256 endTime;\n    uint256 hammerTimeDuration;\n    uint256 bidDecimals;\n    uint256 stepMin;\n    uint256 incMin;\n    uint256 incMax;\n    uint256 bidMultiplier;\n    bool biddingAllowed;\n}\n\nstruct Collection {\n    uint256 startTime;\n    uint256 endTime;\n    uint256 hammerTimeDuration;\n    uint256 bidDecimals;\n    uint256 stepMin;\n    uint256 incMin; // minimal earned incentives\n    uint256 incMax; // maximal earned incentives\n    uint256 bidMultiplier; // bid incentive growth multiplier\n    bool biddingAllowed; // Allow to start/pause ongoing auctions\n}\n\nstruct AppStorage {\n    address pixelcraft;\n    address playerRewards;\n    address daoTreasury;\n    InitiatorInfo initiatorInfo;\n    //Contract address storing the ERC20 currency used in auctions\n    address erc20Currency;\n    mapping(uint256 => TokenRepresentation) tokenMapping; //_auctionId => token_primaryKey\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) auctionMapping; // contractAddress => tokenId => TokenIndex => _auctionId\n    //var storing individual auction settings. if != null, they take priority over collection settings\n    mapping(uint256 => Auction) auctions; //_auctionId => auctions\n    mapping(uint256 => bool) auctionItemClaimed;\n    //var storing contract wide settings. Those are used if no auctionId specific parameters is initialized\n    mapping(address => Collection) collections; //tokencontract => collections\n    mapping(address => mapping(uint256 => uint256)) erc1155TokensIndex; //Contract => TokenID => Amount being auctionned\n    mapping(address => mapping(uint256 => uint256)) erc1155TokensUnderAuction; //Contract => TokenID => Amount being auctionned\n    bytes backendPubKey;\n}\n\ncontract Modifiers {\n    AppStorage internal s;\n\n    modifier onlyOwner() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}"
      },
      "project/contracts/gbm/libraries/LibDiamond.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        if (selectorCount & 7 > 0) {\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}"
      },
      "project/contracts/gbm/libraries/LibSignature.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary LibSignature {\n    function isValid(\n        bytes32 messageHash,\n        bytes memory signature,\n        bytes memory pubKey\n    ) internal pure returns (bool) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (signature.length != 65) {\n            return false;\n        }\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return false;\n        }\n\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\n\n        return (recoveredAddress == address(uint160(uint256(keccak256(pubKey)))));\n    }\n}"
      }
    }
  }
}